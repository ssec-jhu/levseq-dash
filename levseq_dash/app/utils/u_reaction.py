import base64

from rdkit import Chem
from rdkit.Chem import Draw, rdChemReactions


def is_valid_smiles(smiles):
    """
    Args:
        smiles: the smiles string we would like to validate

    Returns:
        MolFromSmiles will sanitize and validat the string. It will return None upon failure.
        It will return the mol if smiles is valid

    """
    if isinstance(smiles, str):
        # remove spaces if any
        smiles = smiles.replace(" ", "")

    if smiles == "":
        # Chem.MolFromSmiles accepts this as a mol! so putting in a check here
        return None

    # MolFromSmiles will sanitize and canonicalize the molecule , defaults to True.
    # example here: https://www.rdkit.org/docs/GettingStartedInPython.html
    # Chem.MolToSmiles(Chem.MolFromSmiles('C1=CC=CN=C1'))
    # >>> 'c1ccncc1'
    # Chem.MolToSmiles(Chem.MolFromSmiles('c1cccnc1'))
    # >>> 'c1ccncc1'
    # Chem.MolToSmiles(Chem.MolFromSmiles('n1ccccc1'))
    # >>> 'c1ccncc1'
    try:
        mol = Chem.MolFromSmiles(smiles)
        return mol
    except Exception as e:
        # this function will rarely throw an exception.
        # One case is when the smiles string is None.
        raise Exception(f"Chem.MolFromSmiles exception:{str(e)} for smiles: {smiles}")


def convert_svg_img_to_src(svg_img):
    """
    Args:
        svg_img: input svg image generated by rdkit
        This is not a function to test whether the input provided is actually an svg input or not.
        User must use this function in conjunction with the output of rdkit only.

    Returns:
        a base64 encoded string transferable for web apps

    """
    if svg_img is None:
        raise ValueError("No svg image was provided to convert.")

    svg_base64 = base64.b64encode(svg_img.encode("utf-8")).decode("utf-8")
    svg_src = f"data:image/svg+xml;base64,{svg_base64}"
    return svg_src


def create_reaction_image(substrate_smiles: str, product_smiles: str):
    """
    Args:
        substrate_smiles: reaction substrate in smiles strings
        product_smiles: reaction product in smiles strings

    Returns:
        image

    """
    # verification for the smiles strings is removed
    # data that comes into the app and is uploaded will go through smiles verification
    # we have exceptions in the initial public data that have no substrates and thus are left as empty strings.
    # but we still need to show the reaction image without a substrate
    if substrate_smiles is None:
        raise ValueError(f"Smiles String is not valid for creating an image: {substrate_smiles}")
    if product_smiles is None:
        raise ValueError(f"Smiles String is not valid for creating an image: {product_smiles}")

    rxn_smarts = f"{substrate_smiles}>>{product_smiles}"
    rxn = rdChemReactions.ReactionFromSmarts(rxn_smarts, useSmiles=True)

    # this function will return a raster image, and you can use
    # this in dash with an html.Img(src=img)
    # img = Draw.ReactionToImage(rxn)
    # return img

    # I am adding an adaptive height and width calculation here based on how internally rdkit
    # is calculating its height and width. I am simply reversing its calculation.
    # rdkit calculation is : width = subImgSize[0] * (rxn.GetNumReactantTemplates() + rxn.GetNumProductTemplates() + 1)
    # ideally a final width of 1000 seems to be working well with the current layout.
    # This number may need to change in the future
    ideal_final_width = 1000
    w = int(ideal_final_width / (rxn.GetNumReactantTemplates() + rxn.GetNumProductTemplates() + 1))

    # if there is an asterisk in substrate or product the:
    if "*" in substrate_smiles or "*" in product_smiles:
        # increase the width a bit more to accommodate the asterisk
        d2d = Draw.MolDraw2DSVG(1000, 200)
        # Assign labels - probably could do this better ... but will have to do for now (toDo: fix)
        r_counter = 1
        for mol in list(rxn.GetReactants()):
            for atom in mol.GetAtoms():
                if atom.GetSymbol() == "*":
                    atom.SetProp("atomLabel", f"R{r_counter}")
                    atom.SetProp("molFileAlias", f"R{r_counter}")
                    r_counter += 1
        r_counter = 1
        for mol in list(rxn.GetProducts()):
            for atom in mol.GetAtoms():
                if atom.GetSymbol() == "*":
                    atom.SetProp("atomLabel", f"R{r_counter}")
                    atom.SetProp("molFileAlias", f"R{r_counter}")
                    r_counter += 1

        d2d.DrawReaction(rxn)
        d2d.FinishDrawing()
        svg_img = d2d.GetDrawingText()
    else:
        # this option produces a svg image
        svg_img = Draw.ReactionToImage(rxn, subImgSize=(w, 200), useSVG=True)

    # convert the svg image to a base64 encoded string
    svg_src = convert_svg_img_to_src(svg_img)

    return svg_src


def create_mols_grid(all_smiles_strings: str):
    """
    this function is a utility function to converts all the smiles string into
    the molecular depiction in grid format. It is used solely for this app.
    Args:
        all_smiles_strings: smiles string containing all the strings semicolon delimited
        this function

    Returns:
        the svg image

    """
    if all_smiles_strings and len(all_smiles_strings) > 0:
        # Clean and split SMILES
        smiles_list = [s.strip() for s in all_smiles_strings.split(";") if s.strip()]
        mols = []
        captions = []

        # go through the list and gather the molecules and their caption/smiles strings
        for smi in smiles_list:
            # if the smiles string is in the system then it's in canonical for but just in case
            # this already makes the molecule internally
            # and probably there is double code here, but I want to keep the semantics of this separate because
            # there may be more validation added to the function then just using Chem.MolFromSmiles(smiles)
            mol = is_valid_smiles(smi)
            if mol is not None:
                mols.append(mol)
                captions.append(smi)

        if mols:
            # make a svg image for better resolution
            # MolsToGridImage is a bit more limited in terms of the layout and the padding that it has,
            # but it is better than loads of code trying to draw on the draw pad
            svg_img = Draw.MolsToGridImage(mols, molsPerRow=8, subImgSize=(200, 200), legends=captions, useSVG=True)
            svg_src = convert_svg_img_to_src(svg_img)

            return svg_src
